{
    "patch": "diff --git a/pygments/lexers/parsers.py b/pygments/lexers/parsers.py\nindex 2e0ae0cc..e6c0eb61 100644\n--- a/pygments/lexers/parsers.py\n+++ b/pygments/lexers/parsers.py\n@@ -296,7 +296,20 @@ class RagelObjectiveCLexer(DelegatingLexer):\n         super().__init__(ObjectiveCLexer, RagelEmbeddedLexer, **options)\n \n     def analyse_text(text):\n-        return '@LANG: objc' in text\n+        # The Ragel host-language marker is optional, so we need to be careful\n+        # not to claim unrelated input. A previous implementation returned\n+        # True when the marker was *not* present, causing this lexer to match\n+        # nearly any text with score 1.0 and win lexer guessing.\n+        #\n+        # Heuristic:\n+        # - strongly prefer explicit \"@LANG: objc\"\n+        # - otherwise only return a low score when the input contains typical\n+        #   Ragel constructs.\n+        if '@LANG: objc' in text:\n+            return 1.0\n+        if '%%{' in text or re.search(r'(?m)^\\s*machine\\s+\\w+', text) or '%%' in text:\n+            return 0.05\n+        return 0.0\n \n \n class RagelJavaLexer(DelegatingLexer):\n@@ -601,8 +614,16 @@ class AntlrJavaLexer(DelegatingLexer):\n         super().__init__(JavaLexer, AntlrLexer, **options)\n \n     def analyse_text(text):\n-        # Antlr language is Java by default\n-        return AntlrLexer.analyse_text(text) and 0.9\n+        # Do not claim arbitrary input: only match when the generic ANTLR\n+        # heuristic matches.  A previous implementation returned 0.1 for\n+        # non-ANTLR text, which made lexer guessing pick this lexer for many\n+        # unrelated languages.\n+        if not AntlrLexer.analyse_text(text):\n+            return 0.0\n+        # If a target language is declared, prefer Java.\n+        if re.search(r'^\\s*language\\s*=\\s*Java\\s*;', text, re.M):\n+            return 1.0\n+        return 0.3\n \n \n class AntlrRubyLexer(DelegatingLexer):\n@@ -623,7 +644,6 @@ class AntlrRubyLexer(DelegatingLexer):\n         return AntlrLexer.analyse_text(text) and \\\n             re.search(r'^\\s*language\\s*=\\s*Ruby\\s*;', text, re.M)\n \n-\n class AntlrPerlLexer(DelegatingLexer):\n     \"\"\"\n     ANTLR with Perl Target\n@@ -642,7 +662,6 @@ class AntlrPerlLexer(DelegatingLexer):\n         return AntlrLexer.analyse_text(text) and \\\n             re.search(r'^\\s*language\\s*=\\s*Perl5\\s*;', text, re.M)\n \n-\n class AntlrActionScriptLexer(DelegatingLexer):\n     \"\"\"\n     ANTLR with ActionScript Target\n@@ -662,7 +681,6 @@ class AntlrActionScriptLexer(DelegatingLexer):\n         return AntlrLexer.analyse_text(text) and \\\n             re.search(r'^\\s*language\\s*=\\s*ActionScript\\s*;', text, re.M)\n \n-\n class TreetopBaseLexer(RegexLexer):\n     \"\"\"\n     A base lexer for `Treetop <http://treetop.rubyforge.org/>`_ grammars.\ndiff --git a/tests/test_guess.py b/tests/test_guess.py\nindex 51644ebd..87759bd2 100644\n--- a/tests/test_guess.py\n+++ b/tests/test_guess.py\n@@ -36,6 +36,16 @@ def test_guess_lexer_brainfuck():\n     lx = guess_lexer('>>[-]<<[->>+<<]')\n     assert lx.__class__.__name__ == 'BrainfuckLexer'\n \n+def test_guess_lexer_cmake():\n+    cmake_code = '''CMAKE_MINIMUM_REQUIRED(VERSION 2.6 FATAL_ERROR)\n+project(example)\n+set(CMAKE_CXX_STANDARD 14)\n+set(SOURCE_FILES main.cpp)\n+add_executable(example ${SOURCE_FILES})'''\n+    lx = guess_lexer(cmake_code)\n+    assert lx.__class__.__name__ == 'CMakeLexer'\n+\n+\n \n def test_guess_lexer_singularity():\n     lx = guess_lexer(get_input('singularity', 'Singularity'))\n",
    "success": false,
    "steps": 27,
    "estimated_tokens": 17944
}