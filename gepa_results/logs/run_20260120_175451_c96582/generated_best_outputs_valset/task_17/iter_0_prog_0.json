{
    "patch": "diff --git a/pygments/lexers/configs.py b/pygments/lexers/configs.py\nindex 365a88a1..8eb35ab4 100644\n--- a/pygments/lexers/configs.py\n+++ b/pygments/lexers/configs.py\n@@ -288,6 +288,85 @@ class KconfigLexer(RegexLexer):\n     # No re.MULTILINE, indentation-aware help text needs line-by-line handling\n     flags = 0\n \n+\n+    def get_tokens_unprocessed(self, text):\n+        \"\"\"Tokenize Kconfig with robust help-text indentation handling.\n+\n+        Help bodies are indentation-sensitive but not guaranteed to be aligned to\n+        8-space tab stops. We detect the indentation prefix from the first\n+        non-blank line after the ``help`` keyword and emit subsequent lines with\n+        at least that indentation as ``String.Doc`` until indentation decreases.\n+        \"\"\"\n+        import re as _re\n+        from pygments.token import Keyword, String, Text\n+\n+        base = super().get_tokens_unprocessed(text)\n+        for pos, ttype, value in base:\n+            yield pos, ttype, value\n+\n+            if ttype is Keyword and value in (\"help\\n\", \"---help---\\n\"):\n+                i = pos + len(value)\n+                n = len(text)\n+\n+                # Blank lines immediately after 'help' are part of the help block.\n+                while i < n:\n+                    j = text.find(\"\\n\", i)\n+                    if j == -1:\n+                        j = n\n+                        line = text[i:j]\n+                        has_nl = False\n+                    else:\n+                        line = text[i:j+1]\n+                        has_nl = True\n+\n+                    if line.strip() == \"\":\n+                        yield i, Text, line\n+                        i = j + (1 if has_nl else 0)\n+                        continue\n+                    break\n+\n+                if i >= n:\n+                    return\n+\n+                j = text.find(\"\\n\", i)\n+                first = text[i:(j + 1 if j != -1 else n)]\n+                m = _re.match(r\"[ \\t]+\", first)\n+                if not m:\n+                    # Not an indented help body; continue normal lexing.\n+                    rest = text[i:]\n+                    for rpos, rttype, rvalue in super().get_tokens_unprocessed(rest):\n+                        yield i + rpos, rttype, rvalue\n+                    return\n+\n+                indent_prefix = m.group(0)\n+\n+                while i < n:\n+                    j = text.find(\"\\n\", i)\n+                    if j == -1:\n+                        j = n\n+                        line = text[i:j]\n+                        has_nl = False\n+                    else:\n+                        line = text[i:j+1]\n+                        has_nl = True\n+\n+                    if line.strip() == \"\":\n+                        yield i, Text, line\n+                        i = j + (1 if has_nl else 0)\n+                        continue\n+\n+                    if line.startswith(indent_prefix):\n+                        yield i, String.Doc, line\n+                        i = j + (1 if has_nl else 0)\n+                        continue\n+\n+                    break\n+\n+                rest = text[i:]\n+                for rpos, rttype, rvalue in super().get_tokens_unprocessed(rest):\n+                    yield i + rpos, rttype, rvalue\n+                return\n+\n     def call_indent(level):\n         # If indentation >= {level} is detected, enter state 'indent{level}'\n         return (_rx_indent(level), String.Doc, f'indent{level}')\n",
    "success": false,
    "steps": 30,
    "estimated_tokens": 18609
}