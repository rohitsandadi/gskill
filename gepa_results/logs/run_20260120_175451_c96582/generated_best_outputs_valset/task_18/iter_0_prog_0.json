{
    "patch": "diff --git a/pygments/lexers/dylan.py b/pygments/lexers/dylan.py\nindex a56ac9a2..9db6c060 100644\n--- a/pygments/lexers/dylan.py\n+++ b/pygments/lexers/dylan.py\n@@ -91,23 +91,22 @@ class DylanLexer(RegexLexer):\n     valid_name = '\\\\\\\\?[\\\\w!&*<>|^$%@\\\\-+~?/=]+'\n \n     def get_tokens_unprocessed(self, text):\n-        for index, token, value in RegexLexer.get_tokens_unprocessed(self, text):\n-            if token is Name:\n+        for index, token, value in super().get_tokens_unprocessed(text):\n+            if token in Name and token not in (Name.Attribute, Name.Class, Name.Tag, Name.Namespace, Name.Label, Name.Decorator):\n                 lowercase_value = value.lower()\n                 if lowercase_value in self.builtins:\n                     yield index, Name.Builtin, value\n                     continue\n-                if lowercase_value in self.keywords:\n-                    yield index, Keyword, value\n-                    continue\n                 if lowercase_value in self.functions:\n                     yield index, Name.Builtin, value\n                     continue\n+                if lowercase_value in self.keywords:\n+                    yield index, Keyword, value\n+                    continue\n                 if lowercase_value in self.operators:\n                     yield index, Operator, value\n                     continue\n             yield index, token, value\n-\n     tokens = {\n         'root': [\n             # Whitespace\n@@ -209,7 +208,6 @@ class DylanLexer(RegexLexer):\n         ]\n     }\n \n-\n class DylanLidLexer(RegexLexer):\n     \"\"\"\n     For Dylan LID (Library Interchange Definition) files.\n@@ -252,28 +250,24 @@ class DylanConsoleLexer(Lexer):\n     version_added = '1.6'\n     _example = 'dylan-console/console.dylan-console'\n \n-    _prompt_re = re.compile(r'\\?| ')\n+    _prompt_re = re.compile(r\"^\\\\?\")\n \n     def get_tokens_unprocessed(self, text):\n         dylexer = DylanLexer(**self.options)\n \n-        curcode = ''\n-        insertions = []\n         for match in line_re.finditer(text):\n             line = match.group()\n-            m = self._prompt_re.match(line)\n-            if m is not None:\n-                end = m.end()\n-                insertions.append((len(curcode),\n-                                   [(0, Generic.Prompt, line[:end])]))\n-                curcode += line[end:]\n-            else:\n-                if curcode:\n-                    yield from do_insertions(insertions,\n-                                             dylexer.get_tokens_unprocessed(curcode))\n-                    curcode = ''\n-                    insertions = []\n+            if line.startswith('?'):\n+                code = line[1:]\n+                # Insert the prompt token at the beginning of the code line.\n+                for idx, tok, val in do_insertions(\n+                    [(0, [(0, Generic.Prompt, '?')])],\n+                    dylexer.get_tokens_unprocessed(code),\n+                ):\n+                    yield match.start() + idx, tok, val\n+            elif line.startswith('=> '):\n                 yield match.start(), Generic.Output, line\n-        if curcode:\n-            yield from do_insertions(insertions,\n-                                     dylexer.get_tokens_unprocessed(curcode))\n+            else:\n+                # Continuation of input (no prompt).\n+                for idx, tok, val in dylexer.get_tokens_unprocessed(line):\n+                    yield match.start() + idx, tok, val\n",
    "success": false,
    "steps": 30,
    "estimated_tokens": 28452
}