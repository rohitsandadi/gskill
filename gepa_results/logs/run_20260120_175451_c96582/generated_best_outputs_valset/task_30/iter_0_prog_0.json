{
    "patch": "diff --git a/pygments/lexers/mime.py b/pygments/lexers/mime.py\nindex 4b309dd0..507f941f 100644\n--- a/pygments/lexers/mime.py\n+++ b/pygments/lexers/mime.py\n@@ -58,9 +58,12 @@ class MIMELexer(RegexLexer):\n \n     def __init__(self, **options):\n         super().__init__(**options)\n+        # Options are documented using header names. Keep those exact keys.\n+        # Defaults are only used when header is missing or when this lexer is\n+        # used standalone.\n+        self.content_type = options.get(\"Content-Type\", \"text/plain\")\n         self.boundary = options.get(\"Multipart-Boundary\")\n-        self.content_transfer_encoding = options.get(\"Content_Transfer_Encoding\")\n-        self.content_type = options.get(\"Content_Type\", \"text/plain\")\n+        self.content_transfer_encoding = options.get(\"Content-Transfer-Encoding\")\n         self.max_nested_level = get_int_opt(options, \"MIME-max-level\", -1)\n \n     def get_header_tokens(self, match):\n@@ -128,29 +131,24 @@ class MIMELexer(RegexLexer):\n             yield pos_part_start, Text, entire_body[lpos_start:]\n \n     def get_bodypart_tokens(self, text):\n-        # return if:\n-        #  * no content\n-        #  * no content type specific\n-        #  * content encoding is not readable\n-        #  * max recurrsion exceed\n-        if not text.strip() or not self.content_type:\n-            return [(0, Other, text)]\n+        if not text:\n+            return []\n \n         cte = self.content_transfer_encoding\n-        if cte and cte not in {\"8bit\", \"7bit\", \"quoted-printable\"}:\n+        if cte and cte not in {\"8bit\", \"quoted-printable\", \"binary\"}:\n             return [(0, Other, text)]\n \n         if self.max_nested_level == 0:\n             return [(0, Other, text)]\n \n-        # get lexer\n         try:\n             lexer = get_lexer_for_mimetype(self.content_type)\n         except ClassNotFound:\n             return [(0, Other, text)]\n \n+        # Avoid infinite recursion when content type points back to MIME.\n         if isinstance(lexer, type(self)):\n-            lexer.max_nested_level = self.max_nested_level - 1\n+            lexer.max_nested_level = self.max_nested_level - 2\n \n         return lexer.get_tokens_unprocessed(text)\n \n@@ -172,13 +170,15 @@ class MIMELexer(RegexLexer):\n \n         if match.group(3).lower() == \"boundary\":\n             boundary = match.group(5).strip()\n-            if boundary[0] == '\"' and boundary[-1] == '\"':\n+            if len(boundary) >= 2 and boundary[0] == boundary[-1] == '\"':\n                 boundary = boundary[1:-1]\n             self.boundary = boundary\n \n+\n     def store_content_transfer_encoding(self, match):\n-        self.content_transfer_encoding = match.group(0).lower()\n-        yield match.start(0), Name.Constant, match.group(0)\n+        # token uses group(1)\n+        self.content_transfer_encoding = match.group(1).lower()\n+        yield match.start(1), Name.Constant, match.group(1)\n \n     attention_headers = {\"content-type\", \"content-transfer-encoding\"}\n \n",
    "success": false,
    "steps": 22,
    "estimated_tokens": 23648
}