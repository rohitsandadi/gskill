{
    "patch": "diff --git a/pygments/cmdline.py b/pygments/cmdline.py\nindex df1c3b7a..c8d13625 100644\n--- a/pygments/cmdline.py\n+++ b/pygments/cmdline.py\n@@ -41,12 +41,16 @@ def _parse_options(o_strs):\n         for o_arg in o_args:\n             o_arg = o_arg.strip()\n             try:\n+                # Only split on the first '=' so values can contain '='.\n                 o_key, o_val = o_arg.split('=', 1)\n                 o_key = o_key.strip()\n                 o_val = o_val.strip()\n             except ValueError:\n+                # A key without an explicit value is treated as a boolean flag.\n                 opts[o_arg] = True\n             else:\n+                # Keep the original value; individual consumers decide how to\n+                # interpret it (e.g. case sensitivity).\n                 opts[o_key] = o_val\n     return opts\n \n@@ -69,18 +73,17 @@ def _print_help(what, name):\n         if what == 'lexer':\n             cls = get_lexer_by_name(name)\n             print(f\"Help on the {cls.name} lexer:\")\n-            print(dedent(cls.__doc__))\n+            print(dedent(cls.__doc__ or '').strip())\n         elif what == 'formatter':\n-            cls = find_formatter_class(name)\n+            cls = get_formatter_by_name(name)\n             print(f\"Help on the {cls.name} formatter:\")\n-            print(dedent(cls.__doc__))\n+            print(dedent(cls.__doc__ or '').strip())\n         elif what == 'filter':\n             cls = find_filter_class(name)\n             print(f\"Help on the {name} filter:\")\n-            print(dedent(cls.__doc__))\n+            print(dedent(cls.__doc__ or '').strip())\n         return 0\n-    except (AttributeError, ValueError):\n-        print(f\"{what} not found!\", file=sys.stderr)\n+    except (AttributeError, ValueError, ClassNotFound):\n         return 1\n \n \n@@ -192,7 +195,6 @@ def main_inner(parser, argns):\n     def is_only_option(opt):\n         return not any(v for (k, v) in vars(argns).items() if k != opt)\n \n-    # handle ``pygmentize -L``\n     if argns.L is not None:\n         arg_set = set()\n         for k, v in vars(argns).items():\n@@ -206,14 +208,13 @@ def main_inner(parser, argns):\n             parser.print_help(sys.stderr)\n             return 2\n \n-        # print version\n         if not argns.json:\n             main(['', '-V'])\n         allowed_types = {'lexer', 'formatter', 'filter', 'style'}\n         largs = [arg.rstrip('s') for arg in argns.L]\n         if any(arg not in allowed_types for arg in largs):\n             parser.print_help(sys.stderr)\n-            return 0\n+            return 2\n         if not largs:\n             largs = allowed_types\n         if not argns.json:\n@@ -223,21 +224,18 @@ def main_inner(parser, argns):\n             _print_list_as_json(largs)\n         return 0\n \n-    # handle ``pygmentize -H``\n     if argns.H:\n         if not is_only_option('H'):\n             parser.print_help(sys.stderr)\n             return 2\n-        what, name = argns.H\n+        name, what = argns.H\n         if what not in ('lexer', 'formatter', 'filter'):\n             parser.print_help(sys.stderr)\n             return 2\n         return _print_help(what, name)\n \n-    # parse -O options\n     parsed_opts = _parse_options(argns.O or [])\n \n-    # parse -P options\n     for p_opt in argns.P or []:\n         try:\n             name, value = p_opt.split('=', 1)\n@@ -246,11 +244,9 @@ def main_inner(parser, argns):\n         else:\n             parsed_opts[name] = value\n \n-    # encodings\n     inencoding = parsed_opts.get('inencoding', parsed_opts.get('encoding'))\n     outencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))\n \n-    # handle ``pygmentize -N``\n     if argns.N:\n         lexer = find_lexer_class_for_filename(argns.N)\n         if lexer is None:\n@@ -259,7 +255,6 @@ def main_inner(parser, argns):\n         print(lexer.aliases[0])\n         return 0\n \n-    # handle ``pygmentize -C``\n     if argns.C:\n         inp = sys.stdin.buffer.read()\n         try:\n@@ -270,7 +265,6 @@ def main_inner(parser, argns):\n         print(lexer.aliases[0])\n         return 0\n \n-    # handle ``pygmentize -S``\n     S_opt = argns.S\n     a_opt = argns.a\n     if S_opt is not None:\n@@ -292,24 +286,16 @@ def main_inner(parser, argns):\n         print(fmter.get_style_defs(a_opt or ''))\n         return 0\n \n-    # if no -S is given, -a is not allowed\n     if argns.a is not None:\n         parser.print_help(sys.stderr)\n         return 2\n \n-    # parse -F options\n     F_opts = _parse_filters(argns.F or [])\n-\n-    # -x: allow custom (eXternal) lexers and formatters\n     allow_custom_lexer_formatter = bool(argns.x)\n \n-    # select lexer\n     lexer = None\n-\n-    # given by name?\n     lexername = argns.l\n     if lexername:\n-        # custom lexer, located relative to user's cwd\n         if allow_custom_lexer_formatter and '.py' in lexername:\n             try:\n                 filename = None\n@@ -318,8 +304,6 @@ def main_inner(parser, argns):\n                     filename, name = lexername.rsplit(':', 1)\n \n                     if '.py' in name:\n-                        # This can happen on Windows: If the lexername is\n-                        # C:\\lexer.py -- return to normal load path in that case\n                         name = None\n \n                 if filename and name:\n@@ -337,7 +321,6 @@ def main_inner(parser, argns):\n                 print('Error:', err, file=sys.stderr)\n                 return 1\n \n-    # read input code\n     code = None\n \n     if argns.INPUTFILE:\n@@ -351,12 +334,11 @@ def main_inner(parser, argns):\n             with open(infn, 'rb') as infp:\n                 code = infp.read()\n         except Exception as err:\n-            print('Error: cannot read infile:', err, file=sys.stderr)\n+            print('Error:', err, file=sys.stderr)\n             return 1\n         if not inencoding:\n             code, inencoding = guess_decode(code)\n \n-        # do we have to guess the lexer?\n         if not lexer:\n             try:\n                 lexer = get_lexer_for_filename(infn, code, **parsed_opts)\n@@ -373,26 +355,22 @@ def main_inner(parser, argns):\n                 print('Error:', err, file=sys.stderr)\n                 return 1\n \n-    elif not argns.s:  # treat stdin as full file (-s support is later)\n-        # read code from terminal, always in binary mode since we want to\n-        # decode ourselves and be tolerant with it\n-        code = sys.stdin.buffer.read()  # use .buffer to get a binary stream\n+    elif not argns.s: \n+        code = sys.stdin.buffer.read()\n         if not inencoding:\n             code, inencoding = guess_decode_from_terminal(code, sys.stdin)\n-            # else the lexer will do the decoding\n         if not lexer:\n             try:\n                 lexer = guess_lexer(code, **parsed_opts)\n             except ClassNotFound:\n                 lexer = TextLexer(**parsed_opts)\n \n-    else:  # -s option needs a lexer with -l\n+    else: \n         if not lexer:\n             print('Error: when using -s a lexer has to be selected with -l',\n                   file=sys.stderr)\n             return 2\n \n-    # process filters\n     for fname, fopts in F_opts:\n         try:\n             lexer.add_filter(fname, **fopts)\n@@ -400,17 +378,14 @@ def main_inner(parser, argns):\n             print('Error:', err, file=sys.stderr)\n             return 1\n \n-    # select formatter\n     outfn = argns.o\n     fmter = argns.f\n     if fmter:\n-        # custom formatter, located relative to user's cwd\n         if allow_custom_lexer_formatter and '.py' in fmter:\n             try:\n                 filename = None\n                 name = None\n                 if ':' in fmter:\n-                    # Same logic as above for custom lexer\n                     filename, name = fmter.rsplit(':', 1)\n \n                     if '.py' in name:\n@@ -453,19 +428,14 @@ def main_inner(parser, argns):\n                 fmter = TerminalFormatter(**parsed_opts)\n         outfile = sys.stdout.buffer\n \n-    # determine output encoding if not explicitly selected\n     if not outencoding:\n         if outfn:\n-            # output file? use lexer encoding for now (can still be None)\n             fmter.encoding = inencoding\n         else:\n-            # else use terminal encoding\n             fmter.encoding = terminal_encoding(sys.stdout)\n \n-    # provide coloring under Windows, if possible\n     if not outfn and sys.platform in ('win32', 'cygwin') and \\\n-       fmter.name in ('Terminal', 'Terminal256'):  # pragma: no cover\n-        # unfortunately colorama doesn't support binary streams on Py3\n+       fmter.name in ('Terminal', 'Terminal256'):\n         outfile = UnclosingTextIOWrapper(outfile, encoding=fmter.encoding)\n         fmter.encoding = None\n         try:\n@@ -476,18 +446,13 @@ def main_inner(parser, argns):\n             outfile = colorama.initialise.wrap_stream(\n                 outfile, convert=None, strip=None, autoreset=False, wrap=True)\n \n-    # When using the LaTeX formatter and the option `escapeinside` is\n-    # specified, we need a special lexer which collects escaped text\n-    # before running the chosen language lexer.\n     escapeinside = parsed_opts.get('escapeinside', '')\n     if len(escapeinside) == 2 and isinstance(fmter, LatexFormatter):\n         left = escapeinside[0]\n         right = escapeinside[1]\n         lexer = LatexEmbeddedLexer(left, right, lexer)\n \n-    # ... and do it!\n     if not argns.s:\n-        # process whole input as per normal...\n         try:\n             highlight(code, lexer, fmter, outfile)\n         finally:\n@@ -495,7 +460,6 @@ def main_inner(parser, argns):\n                 outfile.close()\n         return 0\n     else:\n-        # line by line processing of stdin (eg: for 'tail -f')...\n         try:\n             while 1:\n                 line = sys.stdin.buffer.readline()\n@@ -507,7 +471,7 @@ def main_inner(parser, argns):\n                 if hasattr(outfile, 'flush'):\n                     outfile.flush()\n             return 0\n-        except KeyboardInterrupt:  # pragma: no cover\n+        except KeyboardInterrupt:\n             return 0\n         finally:\n             if outfn:\n",
    "success": false,
    "steps": 25,
    "estimated_tokens": 22025
}